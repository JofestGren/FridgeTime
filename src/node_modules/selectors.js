import * as R from 'ramda'

export const getCategories = state => R.values(state.categories)

export const getRecipeById = (state, id) => R.prop(id, state.recipes)

export const getRecipe = (state, id) => R.prop(id, state.recipe)

export const getRecipes = state => {
  const recipes = R.compose(
    R.map(id => getRecipeById(state, id)) 
  )(state.recipesPage.ids)
  return recipes
}

export const getRenderRecipesLength = state => R.length(state.recipesPage.ids)

export const getTotalBasketCount = state => R.length(state.basketPage)

export const getTotalBasketTime = state => {
  const totalTime = R.compose(
    R.sum,
    R.pluck('totalTimeInSeconds'),
    R.map(id => getRecipeById(state, id))
  )(state.basketPage)

  const minutes = totalTime/60
  if (minutes > 59 && minutes%60 !== 0) {
    return `${Math.floor(minutes/60)} hr ${minutes%60} min`
  } else if (minutes > 59 && minutes%60 === 0) {
    return `${Math.floor(minutes/60)} hr`
  }

  return `${minutes} min`
}

export const getTotalBasketCalories = state => {
  const tempIsCalories = item => R.contains(
    'ENERC_KCAL',
    R.prop('attribute', item)
  )

  const isCalories = item => {
    if (item !== undefined) {
      const temp = R.filter(tempIsCalories, item)
      return R.pluck('value', temp)
    }
  }

  const getBasketRecipes = (state, id) => R.prop(id, state.basket)

  const totalCalories = R.compose(
    R.sum,
    R.map(id => isCalories(id)),
    R.pluck('nutritionEstimates'),
    R.map(id => getBasketRecipes(state, id))
  )(state.basketPage)

  if (!isNaN(totalCalories)) {
    return Math.round(totalCalories)
  }
}

export const getBasketRecipes = state => {
  const getBasketRecipeById = (state, id) => R.prop(id, state.basket)

  const recipes = R.compose(
    R.map(id => getBasketRecipeById(state, id)) 
  )(state.basketPage)
  return recipes
}

export const getAllIngredientsList = state => {
  const recipes = getBasketRecipes(state)
  let linesItem = ``

  recipes.forEach(recipe => {
    recipe.ingredientLines.forEach(element => {
      linesItem += `${element} \n`
    })
  })

  return linesItem
}

export const getIsSearchPressed = state => {
  return state.loading
}

export const getRecipeInBasket = (state) => {
  return state.basketPage
}

export const getBasketShopList = state => {
  const recipes = getBasketRecipes(state)
  let resultIngredients = []
  let counter = 0

  recipes.forEach(recipe => {
    recipe.ingredientLines.forEach((element) => {
      resultIngredients[counter] = element
      counter++
    })
  })

  // console.log('resultIngredients', resultIngredients)

  return resultIngredients
}

export const getSortIngredientsList = state => {
  const getBasketRecipeByIdInRecipes = (state, id) => R.prop(id, state.recipes)

  const recipesBasket = R.compose(
    R.map(id => getBasketRecipeByIdInRecipes(state, id))
  )(state.basketPage)

  let ingredients = []
  let counterIngredients = 0

  recipesBasket.forEach(recipes => {
    recipes.ingredients.forEach(ingredient => {
      ingredients[counterIngredients] = ingredient
      counterIngredients++
    })
  })  

  const count = names => 
    names.reduce((a, b) => 
      Object.assign(a, {[b]: (a[b] || 0) + 1}), {})
  
  // const duplicates = dict => 
  //   Object.keys(dict).filter((a) => dict[a] > 1)

  const resultList = count(ingredients)

  // const duplicatesList = duplicates(resultList)

  // console.log('ingredients', ingredients)
  // console.log('duplicates', duplicatesList)

  // let objDuplicatesNumber = {}

  // duplicatesList.forEach(elementDuplicatesList => {
  //   ingredients.forEach((elementIngredients, i) => {
  //     if (elementDuplicatesList === elementIngredients) {
  //       if (objDuplicatesNumber[elementIngredients]) {
  //         let tempDuplicateNumber = objDuplicatesNumber[elementIngredients]
  //         tempDuplicateNumber.push(i)
  //         objDuplicatesNumber[elementIngredients] = tempDuplicateNumber
  //       } else {
  //         let tempDuplicateNumber = [i]
  //         objDuplicatesNumber[elementIngredients] = tempDuplicateNumber
  //       }
  //     }
  //   })
  // })

  // console.log('objDuplicatesNumber', objDuplicatesNumber)

  let resultShopList = []
  let counterShopList = 0

  for (let key in resultList) {
    // resultShopList[counterShopList] = `${resultList[key]} ${key}`
    resultShopList[counterShopList] = `${key}`    
    counterShopList++
  }

  return resultShopList
}

// export const getSortIngredientsList = state => {
//   const recipes = getBasketRecipes(state)

//   const isNumeric = (n) => {
//     return !isNaN(parseFloat(n)) && isFinite(n);
//   }

//   let counter = 0
//   let counterOther = 0
//   let linesItem = []
//   let otherLines = []
//   let linesItemDesc = []
//   let finallyLines = []

  // recipes.forEach(recipe => {
  //   recipe.ingredientLines.forEach(element => {
  //     const tempElement = isNumeric(element.split(' ', 1))
  //     if(tempElement) {
  //       linesItem[counter] = element.substring(element.indexOf(' ') + 1, element.length)
  //       linesItemDesc[counter] = element.substr(element.indexOf(' ') - 1, 1)
  //       counter++
  //     } else {
  //       otherLines[counterOther] = element
  //       counterOther++
  //     }
  //   })
  // })

//   let uniq = linesItem
//   .map((name) => {
//     return {count: 1, name: name}
//   })
//   .reduce((a, b) => {
//     a[b.name] = (a[b.name] || 0) + b.count
//     return a
//   }, {})

//   let duplicates = Object.keys(uniq).filter((a) => uniq[a] > 1)
//   duplicates.forEach(element => {
//     let quantity = 0
//     let counterTemp = 0
//     let tempCountArr = []
//     let finallyLine = ``

//     linesItem.forEach((item, i) => {
//       if (element === item) {
//         tempCountArr[counterTemp] = i
//         quantity += +linesItemDesc[i]
//         finallyLine = `${quantity} ${element}`
//         counterTemp++
//       }
//     })

//     tempCountArr.forEach((value, i) => {
//       linesItem.splice(value-i, 1) 
//       linesItemDesc.splice(value-i, 1)
//     })

//     finallyLines.push(finallyLine)
//   })

//   const notDupicates = linesItemDesc.map((value, index) => {
//     return `${value} ${linesItem[index]}`
//   })

//   const answerLines = finallyLines.concat(notDupicates, otherLines)

//   console.log('duplicates', duplicates)
//   console.log('answerLines', answerLines)

//   return answerLines
// }

export const getRecipeCalories = state => {
  const recipe = getRecipe(state, state.recipePage.id)

  const isCalories = (n) => {
    const tempattribute = R.prop('attribute', n)
    if (tempattribute === 'ENERC_KCAL') {
      return tempattribute
    }
  }

  if (recipe !== undefined) {
    const recipeCalories = R.filter(isCalories ,recipe.nutritionEstimates)
    return recipeCalories[0]
  }
}