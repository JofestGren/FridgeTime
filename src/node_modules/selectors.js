import * as R from 'ramda'

export const getCategories = state => R.values(state.categories)

export const getRecipeById = (state, id) => R.prop(id, state.recipes)

export const getRecipe = (state, id) => R.prop(id, state.recipe)

export const getRecipes = state => {
  const recipes = R.compose(
    R.map(id => getRecipeById(state, id)) 
  )(state.recipesPage.ids)
  return recipes
}

export const getRenderRecipesLength = state => R.length(state.recipesPage.ids)

export const getTotalBasketCount = state => R.length(state.basketPage)

export const getTotalBasketTime = state => {
  const totalTime = R.compose(
    R.sum,
    R.pluck('totalTimeInSeconds'),
    R.map(id => getRecipeById(state, id))
  )(state.basketPage)

  const minutes = totalTime/60
  if (minutes > 59 && minutes%60 !== 0) {
    return `${Math.floor(minutes/60)} hr ${minutes%60} min`
  } else if (minutes > 59 && minutes%60 === 0) {
    return `${Math.floor(minutes/60)} hr`
  }

  return `${minutes} min`
}

export const getBasketRecipes = state => {
  const getBasketRecipeById = (state, id) => R.prop(id, state.basket)

  const recipes = R.compose(
    R.map(id => getBasketRecipeById(state, id)) 
  )(state.basketPage)
  return recipes
}

export const getAllIngredientsList = state => {
  const recipes = getBasketRecipes(state)
  let linesItem = ``

  recipes.forEach(recipe => {
    recipe.ingredientLines.forEach(element => {
      linesItem += `${element} \n`
    })
  })

  return linesItem
}

export const getIsSearchPressed = state => {
  return state.loading
}

export const getSortIngredientsList = state => {
  const recipes = getBasketRecipes(state)

  const isNumeric = (n) => {
    return !isNaN(parseFloat(n)) && isFinite(n);
  }

  let counter = 0
  let counterOther = 0
  let linesItem = []
  let otherLines = []
  let linesItemDesc = []
  let finallyLines = []

  recipes.forEach(recipe => {
    recipe.ingredientLines.forEach(element => {
      const tempElement = isNumeric(element.split(' ', 1))
      if(tempElement) {
        linesItem[counter] = element.substring(element.indexOf(' ') + 1, element.length)
        linesItemDesc[counter] = element.substr(element.indexOf(' ') - 1, 1)
        counter++
      } else {
        otherLines[counterOther] = element
        counterOther++
      }
    })
  })

  let uniq = linesItem
  .map((name) => {
    return {count: 1, name: name}
  })
  .reduce((a, b) => {
    a[b.name] = (a[b.name] || 0) + b.count
    return a
  }, {})

  let duplicates = Object.keys(uniq).filter((a) => uniq[a] > 1)
  duplicates.forEach(element => {
    let quantity = 0
    let counterTemp = 0
    let tempCountArr = []
    let finallyLine = ``

    linesItem.forEach((item, i) => {
      if (element === item) {
        tempCountArr[counterTemp] = i
        quantity += +linesItemDesc[i]
        finallyLine = `${quantity} ${element}`
        counterTemp++
      }
    })

    tempCountArr.forEach((value, i) => {
      linesItem.splice(value-i, 1) 
      linesItemDesc.splice(value-i, 1)
    })

    finallyLines.push(finallyLine)
  })

  const notDupicates = linesItemDesc.map((value, index) => {
    return `${value} ${linesItem[index]}`
  })

  const answerLines = finallyLines.concat(notDupicates, otherLines)

  console.log('duplicates', duplicates)
  console.log('answerLines', answerLines)

  return answerLines
}